#version 120

// Bluebush 4.3 Main Vertex Shader

attribute vec4 PA;	// Position / Alpha
attribute vec4 RA;	// Rotation Quaternion
attribute vec4 SX;	// Scale / Vector
attribute vec4 TD;	// TexOffset / DisplacementOffset / DisplacementMix / blank
attribute vec4 OT; // OTmix / OTMidpoint / OffsetZ,OTzoom / OThalfExtents

varying vec4 Color;
varying vec4 Tex_Fres;
varying float Alpha;

varying vec3 justNormal;

varying vec4 vFrag; // Vertex
varying vec4 eFrag; // Eye
varying vec3 nFrag; // Normal

varying float distToCamera;
varying vec4 worldPosition;

varying vec4 texOffsets;

varying float displacementMix;
varying vec2 displacementCoords;

float atlasPixel = 1.0f / 2048.0f; // One pixel worth in atlas 0-1 format.

// Unpack Orthotex attributes
varying float OTmix;
varying float OTZoffset;
varying float OTzoom;
varying vec4 vert;

varying vec2 OTmidP0;
varying vec2 OTmidP1;
varying vec2 OTmidP2;
varying vec2 OTmidP3;
varying vec2 OTmidP4;
varying vec2 OTmidP5;
varying vec2 OThalfExtents; // All parts are the same dimensions (px)
varying vec2 OTextentPixels; // All parts are the same dimensions (Atlasy format)
varying vec2 OTtopLeft0;
varying vec2 OTtopLeft1;
varying vec2 OTtopLeft2;
varying vec2 OTtopLeft3;
varying vec2 OTtopLeft4;
varying vec2 OTtopLeft5;

void main()
{
	// Rotation

	vec4 q = vec4(RA.x, RA.y, RA.z, RA.w); // Quaternion
  	vec3 v = vec3 (gl_Vertex.x * 0.01f, gl_Vertex.y * 0.01f, gl_Vertex.z * 0.01f);
  	vec4 rot_vert = vec4(v + 2.0f * cross(q.xyz, cross(q.xyz, v) + q.w * v), 1.0f);

	// Normal Rotation

	vec3 n = gl_Normal.xyz;
	vec4 FinalNormal = vec4(n + 2.0f * cross(q.xyz, cross(q.xyz, n) + q.w * n), 0.0f);

	// Plane vector

	vec3 new_y = normalize(cross(SX.yzw, vec3(1,0,0)));
	vec3 new_x = normalize(cross(new_y, SX.yzw));

	vec4 rot_vert2 = rot_vert;
	rot_vert.x = dot(new_x, rot_vert2.xyz);
	rot_vert.y = dot(new_y, rot_vert2.xyz);
	rot_vert.z = dot(SX.yzw, rot_vert2.xyz);

	vec4 FinalNormal2 = FinalNormal;
	FinalNormal.x = dot(new_x, FinalNormal2.xyz);
	FinalNormal.y = dot(new_y, FinalNormal2.xyz);
	FinalNormal.z = dot(SX.yzw, FinalNormal2.xyz);

	// Scale and Translate
	mat4 translateScale = mat4(
			SX.x, 0.0, 0.0, 0.0,
			0.0, SX.x, 0.0, 0.0,
			0.0, 0.0, SX.x, 0.0,
			PA.x * 0.01, PA.y * 0.01, PA.z * 0.01, 1.0);

	vec4 Finalprod = translateScale * rot_vert;

	gl_Position = gl_ModelViewProjectionMatrix * Finalprod;
	worldPosition = Finalprod;	
	Color = gl_Color;
	Alpha = PA.a;

	Tex_Fres.x = atlasPixel * mod(gl_MultiTexCoord0.x, 2048);	// Pass TexCoord
	Tex_Fres.y = atlasPixel * floor(gl_MultiTexCoord0.x / 2048);
	Tex_Fres.zw = gl_MultiTexCoord0.zw;	// and Fresnel and EnvMap ratio floats

	vFrag = gl_ModelViewMatrix * Finalprod;
	eFrag = gl_ProjectionMatrixInverse * vec4(0,0,-1,0);
	nFrag = normalize(gl_NormalMatrix * vec3(FinalNormal));
	
	justNormal = gl_Normal;

	// Distance to camera
	distToCamera = gl_Position.w;

	texOffsets = vec4 (mod(TD.x, 2048) * atlasPixel, floor(TD.x / 2048) * atlasPixel, // Texture scrolling
					   mod(TD.y, 2048) * atlasPixel, floor(TD.y / 2048) * atlasPixel); // Displacement offset
	
	displacementMix = TD.z; // Just use the entire component.
	displacementCoords.x = atlasPixel * mod(gl_MultiTexCoord0.y, 2048); // Location of displacementMap (from VBO texcoords)
	displacementCoords.y = atlasPixel * floor(gl_MultiTexCoord0.y / 2048);
		
	// Unpack Orthotex attributes
	
	OTmix = OT.x; // OTmix is just the whole component
	vec2 subimage_OTmidpoint = vec2( mod(OT.y, 2048), floor(OT.y / 2048) ); // Load absolute atlas midpoint in px
	OTZoffset = mod(OT.z, 2048) * atlasPixel; // When this crosses the sign -/+ it jiggles the OTzoom a tiny fraction, this can be 'fixed' by offsetting into a higher positive number.
	OTzoom = floor(OT.z / 2048);
	vec2 subimage_OThalfExtents = vec2(mod(OT.w, 2048), floor(OT.w / 2048)); // Half-Extents in px. (whole six-part subimage)
	vec2 subimage_OTtopLeft = vec2 ( subimage_OTmidpoint.x - subimage_OThalfExtents.x, subimage_OTmidpoint.y - subimage_OThalfExtents.y); // In px. (whole 6-part subimage)
	
	// Calculate the six texture samples
	
	float orthoMidpoint = subimage_OTtopLeft.x + (subimage_OThalfExtents.x / 6.0f);						
	float orthoDelta = (subimage_OThalfExtents.x * 2.0f) / 6.0f;
	
	OTmidP0 = vec2( orthoMidpoint * atlasPixel, subimage_OTmidpoint.y * atlasPixel );
	OTmidP1 = vec2( (orthoMidpoint + (orthoDelta * 1.0f)) * atlasPixel, subimage_OTmidpoint.y * atlasPixel );
	OTmidP2 = vec2( (orthoMidpoint + (orthoDelta * 2.0f)) * atlasPixel, subimage_OTmidpoint.y * atlasPixel );
	OTmidP3 = vec2( (orthoMidpoint + (orthoDelta * 3.0f)) * atlasPixel, subimage_OTmidpoint.y * atlasPixel );
	OTmidP4 = vec2( (orthoMidpoint + (orthoDelta * 4.0f)) * atlasPixel, subimage_OTmidpoint.y * atlasPixel );
	OTmidP5 = vec2( (orthoMidpoint + (orthoDelta * 5.0f)) * atlasPixel, subimage_OTmidpoint.y * atlasPixel );
	OThalfExtents = vec2( (subimage_OThalfExtents.x / 6.0f) * atlasPixel, subimage_OThalfExtents.y * atlasPixel );
	OTextentPixels = vec2( 1.0f / (OThalfExtents.x * 2.0f), 1.0f / (OThalfExtents.y * 2.0f) );
	OTtopLeft0 = vec2(subimage_OTtopLeft.x * atlasPixel, subimage_OTtopLeft.y * atlasPixel); // convert to atlas format
	OTtopLeft1 = vec2((subimage_OTtopLeft.x + (orthoDelta * 1.0f)) * atlasPixel, subimage_OTtopLeft.y * atlasPixel);
	OTtopLeft2 = vec2((subimage_OTtopLeft.x + (orthoDelta * 2.0f)) * atlasPixel, subimage_OTtopLeft.y * atlasPixel);
	OTtopLeft3 = vec2((subimage_OTtopLeft.x + (orthoDelta * 3.0f)) * atlasPixel, subimage_OTtopLeft.y * atlasPixel);
	OTtopLeft4 = vec2((subimage_OTtopLeft.x + (orthoDelta * 4.0f)) * atlasPixel, subimage_OTtopLeft.y * atlasPixel);
	OTtopLeft5 = vec2((subimage_OTtopLeft.x + (orthoDelta * 5.0f)) * atlasPixel, subimage_OTtopLeft.y * atlasPixel);
	vert = gl_Vertex;
}
