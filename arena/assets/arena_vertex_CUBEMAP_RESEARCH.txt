#version 120

// Bluebush 4.2 Main Vertex Shader

attribute vec4 PA;	// Position / Alpha
attribute vec4 RA;	// Rotation Quaternion
attribute vec4 SX;	// Scale / Vector
attribute vec4 TD;	// TexOffset / DisplacementOffset
attribute vec4 MX;	// (MTmix, DisplacementMix) / MultiTex zoom / Midpoint of sample / MThalfExtents
attribute vec4 TX;  // (Tmix), Tex zoom / Midpoint of sample / THalfExtents / Toffset (Automatic Texture Offsets)

// attribute vec4 OT; // OTmix,DisplacementMix / OTMidpoint / Midpoint_z,OTzoom / OThalfExtents

varying vec4 Color;
varying vec4 Tex_Fres;
varying float Alpha;

varying vec3 justNormal;

varying vec4 vFrag; // Vertex
varying vec4 eFrag; // Eye
varying vec3 nFrag; // Normal

varying vec3 ReflectDir; // Env Cube mapping

varying float distToCamera;
varying vec4 worldPosition;

varying vec4 texOffsets;

varying float displacementMix;
varying vec2 displacementCoords;

float atlasPixel = 1.0f / 2048.0f; // One pixel worth in atlas 0-1 format.

// Unpack Multi-Texture attributes
varying float mtMix;
varying	vec2 MtHalfExtents;
varying vec2 midpoint;
varying vec2 top_left;
varying vec2 ExtentPixels;
varying float MtZoom;
varying vec4 vert; // We can re-use vert for Auto Texture too.

// Unpack (auto) Texture attributes
varying float tMix;
varying	vec2 tHalfExtents;
varying vec2 toffset;
varying vec2 tmidpoint;
varying vec2 ttop_left;
varying vec2 tExtentPixels;
varying float tZoom;

void main()
{
	// Rotation

	vec4 q = vec4(RA.x, RA.y, RA.z, RA.w); // Quaternion
  	vec3 v = vec3 (gl_Vertex.x * 0.01f, gl_Vertex.y * 0.01f, gl_Vertex.z * 0.01f);
  	vec4 rot_vert = vec4(v + 2.0f * cross(q.xyz, cross(q.xyz, v) + q.w * v), 1.0f);

	// Normal Rotation

	vec3 n = gl_Normal.xyz;
	vec4 FinalNormal = vec4(n + 2.0f * cross(q.xyz, cross(q.xyz, n) + q.w * n), 0.0f);

	// Plane vector

	vec3 new_y = normalize(cross(SX.yzw, vec3(1,0,0)));
	vec3 new_x = normalize(cross(new_y, SX.yzw));

	vec4 rot_vert2 = rot_vert;
	rot_vert.x = dot(new_x, rot_vert2.xyz);
	rot_vert.y = dot(new_y, rot_vert2.xyz);
	rot_vert.z = dot(SX.yzw, rot_vert2.xyz);

	vec4 FinalNormal2 = FinalNormal;
	FinalNormal.x = dot(new_x, FinalNormal2.xyz);
	FinalNormal.y = dot(new_y, FinalNormal2.xyz);
	FinalNormal.z = dot(SX.yzw, FinalNormal2.xyz);

	// Scale and Translate
	mat4 translateScale = mat4(
			SX.x, 0.0, 0.0, 0.0,
			0.0, SX.x, 0.0, 0.0,
			0.0, 0.0, SX.x, 0.0,
			PA.x * 0.01, PA.y * 0.01, PA.z * 0.01, 1.0);

	vec4 Finalprod = translateScale * rot_vert;

	gl_Position = gl_ModelViewProjectionMatrix * Finalprod;
	worldPosition = Finalprod;	
	Color = gl_Color;
	Alpha = PA.a;

	Tex_Fres.x = atlasPixel * mod(gl_MultiTexCoord0.x, 2048);	// Pass TexCoord
	Tex_Fres.y = atlasPixel * floor(gl_MultiTexCoord0.x / 2048);
	Tex_Fres.zw = gl_MultiTexCoord0.zw;	// and Fresnel and EnvMap ratio floats

	displacementMix = floor(MX.x / 2048) * 0.01f;
	displacementCoords.x = atlasPixel * mod(gl_MultiTexCoord0.y, 2048); // Location of displacementMap
	displacementCoords.y = atlasPixel * floor(gl_MultiTexCoord0.y / 2048);

	vFrag = gl_ModelViewMatrix * Finalprod;
	eFrag = gl_ProjectionMatrixInverse * vec4(0,0,-1,0);
	nFrag = normalize(gl_NormalMatrix * vec3(FinalNormal));

	//ReflectDir = normalize(reflect(Finalprod.xyz, Finalprod.xyz));
	//ReflectDir = normalize(reflect(Finalprod.xyz, eFrag.xyz));
	//vec3 N = normalize(gl_NormalMatrix * vec3(FinalNormal));
	// N looks like nFrag
	//vec3 I = Finalprod.xyz - vec3(gl_ModelViewMatrix[3]);
	//vec3 I = gl_Vertex.xyz - vec3(gl_ModelViewMatrix[3]);
	//vec3 I =  vec3(gl_ModelViewMatrix[3]) * gl_Vertex.xyz;
	//ReflectDir = normalize(reflect(I, nFrag));
	//ReflectDir = normalize(I);
		
	//vec3 Normal = gl_NormalMatrix * gl_Normal.xyz;
	//vec4 Position = gl_ModelViewMatrix * gl_Vertex;
	//vec3 Normal = gl_NormalMatrix * FinalNormal.xyz;
	vec4 Position = gl_ModelViewMatrix * Finalprod;
	//vec3 CameraPosition = vec3(gl_ModelViewMatrix[3]);
	//CameraPosition = -CameraPosition; // Invert the translation.
	//vec3 Reflection = reflect(Position.xyz - CameraPosition, normalize(Normal));
//	vec3 Reflection = reflect(Position.xyz, normalize(Normal));
	vec3 Reflection = reflect(Position.xyz, normalize(nFrag.xyz));
	ReflectDir = vec3(Reflection.x, -Reflection.yz);
	
	// Changes don't seem to work as intended.
	// see grass here facing front, and also
	// rotating with the camera.
	// Maybe integrate eFrag.
	// Changes seem to look at lot like vFrag, right now.

	justNormal = gl_Normal;

	// Distance to camera
	distToCamera = gl_Position.w;

	// Texture scrolling
	texOffsets = vec4 (TD.x * atlasPixel, TD.y * atlasPixel, TD.z * atlasPixel, TD.w * atlasPixel);
	
	// Unpack Multi-Texture attributes
	mtMix = mod(MX.x, 2048) * 0.01f; // The * 0.01f converts it from 'int' to 0.0 to 1.0 value. // Multitexture mix ratio
	MtHalfExtents = vec2(mod(MX.w, 2048) * atlasPixel, floor(MX.w / 2048) * atlasPixel); // Half-Extents in atlas format.
	midpoint = vec2( mod(MX.z, 2048) * atlasPixel, floor(MX.z / 2048) * atlasPixel ); // Load midpoint px and convert to atlas 0-1 format.
	top_left = vec2 ( midpoint.x - MtHalfExtents.x, midpoint.y - MtHalfExtents.y);
	ExtentPixels = vec2(1.0f / (MtHalfExtents.x * 2.0f), 1.0f / (MtHalfExtents.y * 2.0f));
	MtZoom = MX.y;
	vert = gl_Vertex;

	// Unpack (Auto) Texture attributes
	tMix = mod(TX.x, 2048) * 0.01f; // The * 0.01f converts it from 'int' to 0.0 to 1.0 value.; // texture mix ratio
	tHalfExtents = vec2(mod(TX.z, 2048) * atlasPixel, floor(TX.z / 2048) * atlasPixel); // Half-Extents in atlas format.
	tmidpoint = vec2( mod(TX.y, 2048) * atlasPixel, floor(TX.y / 2048) * atlasPixel ); // Load midpoint px and convert to atlas 0-1 format.
	toffset = vec2(mod(TX.w, 2048) * atlasPixel, floor(TX.w / 2048) * atlasPixel); // Automatic Texture offset
	ttop_left = vec2 ( tmidpoint.x - tHalfExtents.x, tmidpoint.y - tHalfExtents.y);
	tExtentPixels = vec2(1.0f / (tHalfExtents.x * 2.0f), 1.0f / (tHalfExtents.y * 2.0f));
	tZoom = floor(TX.x / 2048);	
}
